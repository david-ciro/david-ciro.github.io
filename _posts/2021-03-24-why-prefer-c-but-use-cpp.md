---
layout: post
title:  "I work with C++ but prefer C"
date:   2021-03-24 20:42:44 -0300
categories: jekyll update
---

My first experience with programming was with C, the language of choice in 2005 for the introductory course in computational physics at my Alma Mater. By the end of the course there was a short mention of C++, Python and OOP, but I was not very interested in computational physics and eventually forgot the language syntax. Since I was mainly focused in theoretical research I didn't require advanced numerical routines and my language of choice was not very influential on my everyday activities. During that time I used mostly Mathematica and some Python for scripting, but as computations became more demanding and required more control I started migrating some of my Mathematica code to Python with no much improvement in performance and a huge penalty in usability. At the time I was requiring some uncommon level of control over some stepping procedure and this lead me to the [GSL library](https://www.gnu.org/software/gsl/), which is implemented in C following the guidelines of the GNU software foundation. The excellent [documentation](https://www.gnu.org/software/gsl/doc/html/index.html) of GSL and its usage became my informal programming education and influence my current workflow in C.

By the end of my last post-doc I became curious about the advantages of abstraction and OOP, which led me to C++. Then I engaged in a discussion group with colleges in my Physics department. By the time I was quite confortable with C and didn't see the intrinsic features of C++ as fundamental advantages. Classes felt mostly as structures with internal references to methods, constructors felt like glorified allocators and memory management felt confusing in regards to the lifespan of objects and garbage collection. Of course, due to my C background I became used to memory management and is not something that bothers me. It was clear to me that to achieve abstraction there was a significant effort to separate the user from these tasks and understandably so, nasty bugs can emmerge from bad memory management and the language solution to this problem was to minimize the user interaction with memory.

After some time I ended up in a collaboration with another group developing a set of soil physics simmulators. In this case there was a more ambitious task at hand that required interaction between GUI, databases and a simmulation core. Due to the existence of advanced solutions in C++ it became the language of choice and I became more familiar with it. At this point I feel more confortable but sometimes I find my self struggling to justify excessive use of classes. Moreover, I think that the use of classes is an effort to embeed in the language structure a set of good practices, like protecting the object state and only access and modify it by means of well established methods that give more transparency to the code.

In general I enjoy working in C++, but it bugs me when people talk about things that can not be done in C without having enough experience with the language. The principles of OOP can be applied to any language and I believe that non-profesional C users can benefit from identifying a flexible usage pattern for their structures that guide the development of their methods to achieve encapsulation. My posts and notes will focus mostly on C, the development of simple APIs, implementation separation (not hidding) and the identification of good usage patterns.
